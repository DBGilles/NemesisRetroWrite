
%\chapter{Design}
\label{cha:design}

\section{Introduction}
This section outlines the approach to mitigate Nemesis style attacks. The cause of the vulnerability exposed by Nemesis-style attacks are differences in 
latency traces. Attackers are able to look at the differences in these latency traces and infer which secret-dependent branches were taken by the program, 
leaking information from the program. The algorithm outlined in this section aims to prevent this by aligning the latency traces along various paths by 
inserting additional instructions into corresponding nodes of two different branches, ensuring that there are no differences that can leak information. 

The proposed algorithm performs a number of operations on a programs Control Flow Graph (CFG). The two main operations are the insertion of additional nodes into the graph and the alignment of a set of nodes. 
Because not all CFG structures are suitable for alignment the first stage of the algorithm inserts nodes into the graph to ensure alignment is possible. The second stage consists of alignment corresponding nodes 
in the graph. 

Section \ref{sec:property} will define the property that needs to hold for a program in order for Nemesis-style attacks to be mitigated. Section \ref{sec:cfg} introduces the CFG data structure and translates the aforementioned property to such CFG structures. Finally, sections \ref{seq:equalising} and \ref{seq:alignment} describe the insertion and alignment of nodes, respectively. 

\section{Nemesis-sensitive property}\label{sec:property}
In their paper Pouyanrad et. al have formally defined the Nemesis-Sensitive property.  Let $region^{then}(ep)$ and $region^{else}(ep)$ capture the set of execution points belonging to the branch target and the other region of some branching instruction $ep$. Let $ep^i$ be the i'th instruction in a region. A program P with a secret-dependence branch in $ep$ and $region^{then}(ep)$ 
and region $region^{else}(ep)$ with the same number of execution points, satisfies the nemesis-sensitive property if and only if:  

\begin{equation} \label{eq:nemesisProperty}
    \begin{split}
    \forall ep^i \in region^{then}(ep) : \forall ep^j \in region^{else}(ep) \text{ \textit{such that} } i=j :  \\ 
    (s_{ep^i} \xrightarrow[]{t} s_{ep^i_{next}}) \land (s_{ep^j} \xrightarrow[]{t'} s_{ep^j_{next}}) \iff t = t' \\ 
    \end{split}
\end{equation}
\cite{MSP430Detection}
The relation $s \xrightarrow[]{t} s'$ models the transition between program states $s$ and $s'$, declaring that the transition between $s$ and $s'$ takes a time $t$. 
For a given instruction this time $t$ is equal the instruction's latency. This property states that for any two corresponding instructions in the branches their latencies should be the same.

If this nemesis-sensitive property holds for a program then an attacker is not able to infer which branch was taken by the program based on instruction latencies.

\section{CFG}\label{sec:cfg}
The Control Flow Graph (CFG) is a data structure that represents the control flow of a program. A CFG consists of nodes $V$ and directed edges $E$. Each node $V$ contains a 
contiguous sequence of instructions. Any branching instruction can only occur at the end of such a sequence, and an instruction that is the target of 
of a branching sequence can only occur at the start. 
An edge is drawn from node $v$ to node $v'$ if and only if the last instruction in $v$ can be followed by the first instruction in $v'$ 
when following program control flow. The algorithm only considers branching instructions that are binary in nature, so a node in the CFG can have at most 2 successors. 
By construction of this data structure a branching instruction will always be the last instruction in a node. A node is said to be secret-dependent if its last instructions is a 
secret-dependent branching instruction. 

Each node has a latency sequence associated with it, equal to the latencies of the node's instructions.  
A latency trace along a path of the CFG is then equal to the concatenation of the latency sequences of each node along the path.
Figure \ref{fig:exampleCFG} shows an example of a such a CFG, along with the original program it is created from. The CFG also contains the latency for each instruction. Note that by convention the only node with no incoming edges is considered the starting node of the CFG. 

\begin{figure}
\centering
\begin{subfigure}{.4\textwidth}
  \centering
  
    \begin{lstlisting}[language=C]
int main(){
        int a = 10; 
        int b = 20; 
        if (a < b){
            int temp = b; 
            b = a; 
            a = temp; 
        } 
        return a;  
}\end{lstlisting}
  \caption{C program}
  \label{fig:c_program}
\end{subfigure}%
\begin{subfigure}{.7\textwidth}
  \centering
  \includegraphics[width=.7\textwidth]{images/sample_program_graph.png}
  \caption{Corresponding CFG}
  \label{fig:c_program_cfg}
\end{subfigure}
\caption{Example program with corresponding CFG}
\label{fig:exampleCFG}
\end{figure}

Following the property described in section \ref{eq:nemesisProperty}, the nemesis-sensitive property can be defined for a node in the CFG. Let $v$ be a secret-dependent node. 
Let $v_f$ be a node such that all paths from $v$ to some leaf go through $v_f$. Then $region^{then}(v)$ can be defined as the set of nodes reachable following the 
first of $v$'s outgoing edges up to and including $v_f$ and $region^{else}(v)$ as the set of nodes reachable following the other outgoing edge up to and including $v_f$. Any differences in latencies between two nodes that are descendants of $v_f$ cannot be used to infer information about the secret dependent node $v$. All nodes below $v_f$ therefore do not have to be considered. If no such node $v_f$ exists then the regions simply consists of all nodes reachable from $v$ through one of its outgoing edges. 

Let $n^i \in region(v)$ be a node such that there is a path going to it from node $v$ of length $i$. The depth of $region(v)$ is defined as being the length of the longest path from $v$ to some node $v' \in region(v)$ that does not contain a cycle.

A secret-dependent node $v$ and $region^{then}(v)$ and $region^{else}(v)$ with the same depth satisfies the nemesis-sensitive property if and only if 
\begin{equation} \label{eq:nemesisPropertyNode}
    \begin{split}
    \forall n^i \in region^{then}(v) : \forall n^j \in region^{else}(v) \text{ \textit{such that} } i=j :  \\ 
    latencies(n^i) = latencies(n^j)
    \end{split}
\end{equation}
where $latencies(n)$ is a function mapping a node $n$ to its latency sequence. 

Figure \ref{fig:regionExamples} illustrates how the borders of each region is defined. The secret-dependent node is marked in green, while the two branches are marked in red and blue. In the second example, the node marked in purple belongs to both regions. In example \ref{fig:regionExampleA} there is node node such that all paths from the secret-dependent node to a leaf go through it, so the regions extend all the way to the leaves. In example \ref{fig:regionExampleB} all paths that start in the secret-dependent node go through the node 6. Any differences in nodes 7 and 8 can only be used to infer information about the branch in node 6. These nodes therefore do not have to be considered.  


\begin{figure}
 \centering
 \subfloat[]{\includegraphics[height = 6cm]{images/nemesis-property-example-1.png}\label{fig:regionExampleA}}
 \subfloat[]{\includegraphics[height = 6cm]{images/nemesis-property-example-2.png}\label{fig:regionExampleB}} 

 \captionof{figure}{then-else regions for secret-dependent nodes}
 \label{fig:regionExamples}
\end{figure}

\section{Equalising}\label{seq:equalising}
There are 2 structures commonly found in a program's control flow graph that make it impossible to enforce the nemesis-sensitive property for a node as defined in the previous section, 
shown in figure \ref{fig:problemStructures}.  Before aligning the nodes an equalising step is applied to ensure these structures are do not occur in the CFG. 

\subsection{Problematic structure}
The first such structure occurs when the program contains some sequence of instructions that is only executed if some condition is true.
In this structure there will be some node that has two paths to it of different lengths. One path will contain the node that corresponds to the conditional instructions, while the other path will 
not contain this node. Because the paths have some overlapping nodes and because the paths have different lengths it is impossible to equalize their latency traces by inserting additional instructions, since inserting instructions in one of the paths will also insert instructions into the other path. If these paths start at a secret-dependent node it is therefore impossible to 
ensure that the nemesis-sensitive property holds. 

The second problematic structure occurs when one of the branches is shorter than the other one, as shown in figure \label{fig:unequal}. In such cases there will be some nodes in 
one branch that have no corresponding nodes in the other branch, making it impossible to align them. 

The nemesis-sensitive property as defined in section \ref{eq:nemesisPropertyNode} entails that it is impossible for a node to satisfy the property if one of these 
structures occurs in its branches, since in both cases the regions have different depths. The first stage of the algorithm therefore consists of first equalizing all path lengths and then 
equalizing branches. Algorithms \ref{alg:equalizePaths} and \ref{alg:equalizeBranches} depict pseudo-code for equalizing paths lengths and equalizing branches respectively. 

\subsection{Equalize paths}
To equalize all path lengths starting from some secret-dependent node $v$, first a subset of the graph's nodes are extracted such that 
only the regions $region^{then}(v)$ and $region^{else}(v)$ are considered. This is done by applying a modified breadth-first search that stops early when the 
current node dominates all of the leaves reachable from $n$. By definition all paths between $n$ and a leaf will pass through this node, in which case the 
any of the following nodes no dot have to be considered. Next the length of the longest path is computed  from $v$ to all nodes in the sub-graph. 
If there exists edges such that the length of the longest path to the tail and the length of the longest path to the head differ by more than one then 
there are at least 2 paths to the head of different lengths. In this case additional nodes are inserted between the tail and the head to equalize these path lengths. 

\subsection{Equalize branches}
The branches of a CFG can be equalized in a similar way. Given some secret-dependent node $v$ a subset of the graph's nodes are extracted. 
Next the lengths of the longest paths are computed for all leaves of the sub-graph, as well as the length of the longest path from the root to some leaf. 
If for some leaf the longest path to it is too short then additional nodes are inserted as predecessors to this leaf. 

\begin{figure}
 \centering
 \subfloat[optional node]{\includegraphics[height = 6cm]{images/optional.png}\label{fig:optional}}
 \subfloat[unequal branches]{\includegraphics[height = 6cm]{images/unequal.png}\label{fig:unequal}} 

 \captionof{figure}{problematic structures in CFG}
 \label{fig:problemStructures}
\end{figure}

\section{Alignment} \label{seq:alignment}

During the alignment stage the nodes of the CFG are aligned in a level-wise manner. During this stage additional instructions are inserted into nodes to ensure that corresponding instructions have the same latency.
Algorithm \ref{alg:align} depicts pseudocode for this stage of the algorithm. 

The level of a node is defined as being the distance between the root of the graph and the node. After the first stage of the algorithm all paths to a given nodes have the same length. This makes the level of a node a well 
defined value. The alignment stage iterates over all the levels of the sub-graph and aligns the nodes found at that level. 

\subsection{Basic Operation}
The core of the alignment step consists of repeatedly selecting a reference instruction from one of the nodes and inserting instructions into the other nodes such that the latencies match. The node from which the 
reference instruction is selected is called the reference node. The reference node can change throughout the algorithm. 

Because an instruction is potentially added to each node that is not the reference node, the reference node needs to have at least as many instructions as the node with the largest number of instructions. This ensure that at some point all nodes have the same number of instructions. Let $n_{max}$ be the number of instructions in the longest node. The set of candidate nodes then consists of all nodes that have $n_{max}$ instructions. The reference 
node is then selected from this set of candidates. 

An index variable is used to keep track of the position of the reference instruction. This variable is initially zero and is incremented every iteration. Any instructions that have an index smaller than this variable 
are balanced. The reference instruction is selected by first selecting the reference node and then selecting the instruction in this node that has an index equal to the index variable. 

Given a reference instruction, the algorithm iterates over all nodes that are not the reference node and verifies if the corresponding instruction has the same latency. 
If the two latencies are not equal, or if the node has no corresponding instruction,  then a new instruction is inserted into the node at the index equal to the index variable. 
Once this has been done for all nodes then all instructions with an index smaller than or
equal to the index variable will be balanced and the index variable can be incremented. 

\subsection{Selecting the Reference Node}
If there are multiple candidates nodes then the algorithm selects one of the nodes where the corresponding reference instruction is not a branching instruction or a return statement. From this set a reference node 
is arbitrarily selected. If there are no such nodes then any node can be selected as the reference node.  

\subsection{Constructing NOP instruction}
For each latency class a template NOP instruction has been determined. The instruction can be inserted into the program as-is if it has no effect on the program state, i.e. it does not modify any register values. 
If the instruction does modify some register the algorithm selects a registers that can safely be used. This needs to be a register that is not in use at the time of execution of the instruction. 

The function is statically analyzed to determine which registers are free to use for this purpose. There are two types of free registers. 
A register can be free because its current value is no longer used, i.e. because it is overwritten at some later point without
being read first. Alternatively a register can be free because it isn't used anywhere in the current function. In the latter case, however, it is possible that the register is in use by the caller, 
since there is no guarantee that the caller stored all the registers it uses. 

If a register of the first type exists then it can be used as the operand of the NOP instruction and the resulting instruction 
can be inserted as-is into the node. If no such registers exists, a free register of the second type is selected, and additional instructions are inserted into the program to ensure that the 
original value of the register is not lost. In the root of the CFG additional instructions are inserted to push the register value onto the stack, while in every leaf instructions are inserted 
that pop the value from the stack. 

If there are no free registers available, any register is arbitrarily selected. Additional instructions are inserted before and after the NOP instruction to push and pop the register value. To ensure the nodes are 
still balanced these push and pop instructions are inserted across all nodes of the current level. 

\subsection{branching instructions}
In the cases where the reference instruction is a branching instruction, the newly inserted instruction will also be a branching instruction. The target of the branching instruction is the successor of the node where 
the node is inserted. 


\begin{algorithm*}
  \SetAlgoLined
  \DontPrintSemicolon
  
  \SetKwFunction{equalizePathsFnName}{EqualizePathLengths}
  \SetKwFunction{extractSubgraphFNName}{ExtractSubGraph}
  \SetKwFunction{computeLongestPathFNName}{ComputeLongestPathLengths}
  \SetKwFunction{CreateNodeFNName}{CreateNode}
  \SetKwFunction{InsertNodeFNName}{InsertNodeBetween}
  \SetKwFunction{edges}{Edges}
  \SetKwFunction{nodes}{Nodes}
  \SetKwFunction{leaves}{Leaves}
  \SetKwFunction{topologicalorder}{TopologicalOrder}
  \SetKwFunction{successors}{Successors}
  \SetKwFunction{predecessors}{Predecessors}
  \SetKwFunction{addNode}{AddNode}
  \SetKwFunction{addEdge}{AddEdge}
  \SetKwFunction{removeEdge}{RemoveEdge}
  \SetKwFunction{max}{Max}
  \SetKwProg{equalizePaths}{Procedure}{}{}
  
   \equalizePaths{\equalizePathsFnName{g: CFG, v: Node}}{
   \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
   \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
   \ForAll{(u, v) $\in$ \edges{subgraph}}{
   diff $\leftarrow$  \textit{longestPathLengths}[u] - longestPathLengths[v] \\
   \uIf{diff $>$ 1}{
        \textit{head} $\leftarrow$ v \\ 
        \For{$i \in$ 1, 2, ..., diff-1}{
%            \FSetLatencies(node, target\_latencies)
            \textit{newNode} $\leftarrow$ \CreateNodeFNName{} \\
            \InsertNodeFNName{newNode, u, head} \\
            \textit{head} $\leftarrow$ newNode \\
        }
   }
   }
   }{}
   
     \SetKwProg{ComputeLongestPathLengths}{Function}{}{}
  \ComputeLongestPathLengths{\computeLongestPathFNName{g: CFG, s: Node}}{
  dist = \{n : -1 $\vert$  n $\in$ \nodes{g} \} \\
  dist[s] $\leftarrow$  0 \\
  \ForAll{n $\in$ \topologicalorder{g}}{
    
    \ForAll{succ $\in$ \successors{n}}{
        dist[succ] $\leftarrow$ \max{dist[succ], dist[n] + 1} \\
    }
    
  }
  \KwRet dist \\
  }
  
   \SetKwFunction{computeImmediateDominators}{computeImmediateDominators}
  \SetKwProg{ExtractSubGraph}{Function}{}{}
  \ExtractSubGraph{\extractSubgraphFNName{g: CFG, n: Node}}{
  \textit{immedidateDominators} $\leftarrow$  \computeImmediateDominators{g, n} \\
  \textit{leafDominators} $\leftarrow$  \{ $u$ $\in$ \nodes{g} $\vert(u, v) \in$ \textit{leafDominators} $ \land v \in$ \leaves{g} \} \\
  
  \uIf{$\vert$ leafDominators $\vert$ = 1}{
    dominator $\leftarrow$  leafDominators[0] \\
  } \uElse{
    dominator $\leftarrow$  $\varnothing$ \\
  }
  
 
  \textit{subgraphNodes} $\leftarrow$  [n] \\
  \textit{adjacentNodes}  $\leftarrow$  \successors{n} \\
  \While{$\vert$ adjacentNodes $\vert$ > 0}{
    currentNode $\leftarrow$  adjacentNodes[0] \\
    adjacentNodes $\leftarrow$  adacentNodes $ \setminus $ \{currentNode\} \\
    \uIf{currentNode = dominator}{
        \KwRet \textit{subgraphNodes}
        }
    \textit{adjacentNodes} $\leftarrow$  \textit{adjacentNodes}  $ \bigcup $ $( \successors{currentNode} \setminus \textit{adjacentNodes} )$ \\
  } 
  \KwRet \textit{subgraphNodes}
  }
  
  \caption{Equalize Path Lengths}
  \label{alg:equalizePaths}
\end{algorithm*}

\begin{algorithm*}
    \SetAlgoLined
    \DontPrintSemicolon
    \SetKwProg{equalizeBranches}{Procedure}{}{}
    \SetKwFunction{equalizeBranchesFNName}{EqualizeBranches}

    \equalizeBranches{\equalizeBranchesFNName{g: CFG, n: Node}}{
    \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
    \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
    \textit{maxPathLength} $\leftarrow$ \max{$\{ longestPathLengths[v] \, \vert \,  v \in  \leaves{subgraph}\}$} \\
    \ForAll{leaf $\in$ \leaves{subgraph}}{
        diff $\leftarrow$ \textit{longestPathLengths[leaf]} - maxPathLength \\
        
        \uIf{diff $>$ 0}{
                $v$ $\leftarrow$ leaf \\
                \For{i $\in$ 1, 2, ..., diff}{
                    newNode $\leftarrow$ \CreateNodeFNName{} \\
                    \addNode{g, newNode} \\
                    \ForAll{$p \in$ \predecessors{v}}{
                        \addEdge{g, (p, newNode)} \\
                        \removeEdge{g, (p, v)} \\
                    }
                    \addEdge{g, (newNode, v)} \\
                }
        }
    }
    }
    \caption{Equalize Branches}
    \label{alg:equalizeBranches}
\end{algorithm*}

\begin{algorithm*}      
    \SetAlgoLined
    \DontPrintSemicolon
    
    \SetKwProg{alignCFG}{Procedure}{}{}
    \SetKwProg{alignNodes}{Procedure}{}{}
    
    \SetKwFunction{alignCFGFNName}{AlignCFG}
    \SetKwFunction{alignNodesFNName}{AlignNodes}
    \SetKwFunction{computeDistanceFromNode}{ComputeDistanceFromNode}
    
    \alignCFG{\alignCFGFNName{g: CFG, n: Node}}{
    subgraph $\leftarrow$ \extractSubgraphFNName{g, v} \\
    pathLengths $\leftarrow$ \computeDistanceFromNode{subgraph, v} \\
    levels $\leftarrow$ \{ l $\; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
    \ForAll{l $\in$ levels}{
        levelNodes $\leftarrow$ \{ $u \; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
        \alignNodesFNName{subraph, levelNodes} \\
    }
    }
    
    \SetKwFunction{countInstruction}{CountInstructions}
    \SetKwFunction{selectReferenceNode}{SelectReferenceNode}
    \SetKwFunction{getNodeInstruction}{GetNodeInstruction}
    \SetKwFunction{latency}{Latency}
    \SetKwFunction{isBranch}{IsBranch}
    \SetKwFunction{isReturn}{IsReturn}
    
    \SetKwFunction{selectRegister}{SelectRegister}
    \SetKwFunction{getNOPInstruction}{GetNOPInstruction}
    \SetKwFunction{getBranchInstruction}{GetBranchInstruction}
    \SetKwFunction{insertInstruction}{insertInstruction}
    
    \alignNodes{\alignNodesFNName{g: CFG, ns : NodeSet}}{
    index $\leftarrow$ 0 \\ 
    \While{True}{
        nodeLengths $\leftarrow$ \{ node: \countInstruction{node} $\; \vert \;$ node $\in$ \nodes{g} \} \\
        candidates $\leftarrow$ \{n $\; \vert \;  n \in$ \nodes{g} $\land$  nodeLengths[n] = \max{nodeLengths} \} \\
        referenceNode $\leftarrow$ \selectReferenceNode{candidates} \\
        referenceInstruction $\leftarrow$ \getNodeInstruction{referenceNode, index} \\
        
        \ForAll{node $\in$ \{n $\vert$ n $\in$ \nodes{g} $\land$ n $\neq$ referenceNode \}}{
            \uIf{index $<$ nodeLength[node] $\; \land \;$  \latency{\getNodeInstruction{node, index}} = \latency{referenceInstruction}}{
                continue
            }
            \uIf{\isBranch{referenceInstruction}}{
                newInstruction $\leftarrow$ \getBranchInstruction{}\\ 
                \insertInstruction{node, newInstruction} \\
            } \uElse{
                reg $\leftarrow$ \selectRegister{} \\ 
                newInstruction $\leftarrow$ \getNOPInstruction{\latency{referenceInstruction}, reg} \\ 
                \insertInstruction{node, newInstruction} \\
            }
        }    
    }
    }
    
    \SetKwProg{selectReferenceNode}{Function}{}{}
    \SetKwFunction{selectReferenceNodeFNName}{SelectReferenceNode}

    \selectReferenceNode{\selectReferenceNodeFNName{candidates: NodeSet, index: Integer}}{
        \For{n $\in$ candidates}{
            candidateInstruction $\leftarrow$ \getNodeInstruction{n, index} \\
            \uIf{$\lnot$ (\isBranch{candidateInstruction} $\lor$ \isReturn{candidateInstruction}) }{
                \KwRet n \\
            }
        }
        \KwRet candidates[0] \\
    }
    
    

    
    \caption{Align CFG}
    \label{alg:align}
\end{algorithm*}