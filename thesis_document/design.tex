
\chapter{Design}
\label{cha:design}

\section{Introduction}

The root cause of the vulnerability exposed by Nemesis-style attacks are differences in the latencies of two instruction that occur at the same 
position in two branches of a secret-dependent branching instruction. 
In practice an attacker can exploit this vulnerability by generating latency traces along different paths of the program's control flow. 
Any differences in instruction latencies will be reflected as differences in these latency traces. 
By carefully inspecting the relevant sections of the latency traces the attacker can infer which paths were taken for a given input. 
In cases where the path depends on some secret data the attacker is then able to infer information about this data, successfully leaking information. 

The goal of the algorithm outlined in this section is to ensure that latency traces cannot be used to leak information in this way.
It does this by inserting additional instructions into branches of a secret-dependent branching instruction. These instructions 
are carefully selected such that they have the same latency as their corresponding instruction in the other branch. This ensures that
any instructions that occur at the same position in two different branches have the same latency. As a result the sections of latency traces
that correspond to these branches will be identical, making it impossible for an attacker to infer information. 


The proposed algorithm inserts additional instructions into the program through manipulation of the program's control flow graph. 
This graph consists of nodes and vertices, where each node contains a sequence of instructions. 
One of the main operations performed on the graph is the alignment of a set of nodes. 
This operation inserts additional instructions into nodes such that all instructions at a given position in any of the nodes have the same latency. 

Not all structures found in a control flow graph are suitable for alignment. The aforementioned alignment operation therefore has some conditions on the structure of the control flow graph that need to be met. 
The other main operation of the algorithm therefore consists of inserting additional nodes into the graph such that these conditions are met. 

Section \ref{sec:property} will formally define the property that needs to hold for a program in order for Nemesis-style attacks to be mitigated. Section \ref{sec:cfg} 
introduces the CFG data structure and translates the aforementioned property to such structures. Finally, sections \ref{seq:equalising} and \ref{seq:alignment} describe the insertion and alignment of nodes, respectively. 

\section{Nemesis-sensitive property}\label{sec:property}
In their paper Pouyanrad et. al have formally defined the Nemesis-Sensitive property.  Let $region^{then}(ep)$ and $region^{else}(ep)$ capture the set of execution points belonging to the branch target and the other region of some branching instruction $ep$. Let $ep^i$ be the i'th instruction in a region. A program P with a secret-dependence branch in $ep$ and $region^{then}(ep)$ 
and region $region^{else}(ep)$ with the same number of execution points, satisfies the nemesis-sensitive property if and only if:  

\begin{equation} \label{eq:nemesisProperty}
    \begin{split}
    \forall ep^i \in region^{then}(ep) : \forall ep^j \in region^{else}(ep) \text{ \textit{such that} } i=j :  \\ 
    (s_{ep^i} \xrightarrow[]{t} s_{ep^i_{next}}) \land (s_{ep^j} \xrightarrow[]{t'} s_{ep^j_{next}}) \iff t = t' \\ 
    \end{split}
\end{equation}
\cite{MSP430Detection}

The relation $s \xrightarrow[]{t} s'$ models the transition between program states $s$ and $s'$, declaring that the transition between $s$ and $s'$ takes a time $t$. 
For a given instruction this time $t$ is equal the instruction's latency. This property states that for any two corresponding instructions in the branches their latencies should be the same.

If this nemesis-sensitive property holds for a program then an attacker is not able to infer which branch was taken by the program based on instruction latencies.

\section{CFG}\label{sec:cfg}

The Control Flow Graph (CFG) is a data structure that represents the control flow of a program. A CFG consists of nodes $V$ and directed edges $E$. Each node $V$ contains a 
contiguous sequence of instructions that is always executed as a whole. This implies that any branching instruction can only occur at the end of a node, 
and an instruction that is the target of a branching sequence can only occur at the start. 

An edge is drawn from node $v$ to node $v'$ if and only if the last instruction in $v$ can be followed by the first instruction in $v'$ 
when following program control flow. The algorithm only considers branching instructions that are binary in nature, so a node in the CFG can have at most 2 successors. 
By construction of this data structure a branching instruction will always be the last instruction in a node. A node is said to be secret-dependent if its last instructions is a 
secret-dependent branching instruction. 

Each node has a latency sequence associated with it, equal to the latencies of the node's instructions.  
A latency trace along a path of the CFG is then equal to the concatenation of the latency sequences of each node along the path.
Figure \ref{fig:exampleCFG} shows an example of a such a CFG, along with the original program it is created from. The CFG also contains the latency for each instruction. Note that by convention the only node with no incoming edges is considered the starting node of the CFG. 

\begin{figure}
\centering
\begin{subfigure}{.4\textwidth}
  \centering
  
    \begin{lstlisting}[language=C]
int main(){
        int a = 10; 
        int b = 20; 
        if (a < b){
            int temp = b; 
            b = a; 
            a = temp; 
        } 
        return a;  
}\end{lstlisting}
  \caption{C program}
  \label{fig:c_program}
\end{subfigure}%
\begin{subfigure}{.7\textwidth}
  \centering
  \includegraphics[width=.7\textwidth]{images/sample_program_graph.png}
  \caption{Corresponding CFG}
  \label{fig:c_program_cfg}
\end{subfigure}
\caption{Example program with corresponding CFG}
\label{fig:exampleCFG}
\end{figure}

Following the property described in section \ref{eq:nemesisProperty}, the nemesis-sensitive property can be defined for a node in the CFG. Let $v$ be a secret-dependent node. 
Let $v_f$ be a node such that all paths from $v$ to some leaf go through $v_f$. Then $region^{then}(v)$ can be defined as the set of nodes reachable following the 
first of $v$'s outgoing edges up to and including $v_f$ and $region^{else}(v)$ as the set of nodes reachable following the other outgoing edge up to and including $v_f$.

Any differences in the latency sequences of two nodes can only be used to infer which branch was taken at the nearest branching point that is an ancestor of both nodes. 
Any differences in latencies between two nodes that are descendants of $v_f$ can therefore only be used to infer information about which branch was taken at $v_f$. 
This means that all nodes below $v_f$ do not have to be considered. If no such node $v_f$ exists then the regions simply consists of all nodes reachable from $v$ through one of its outgoing edges. 

Let $n^i \in region(v)$ be a node such that there is a path going to it from node $v$ of length $i$. The depth of $region(v)$ is defined as being the length of the longest path from $v$ to some node $v' \in region(v)$ that does not contain a cycle.

A secret-dependent node $v$ and $region^{then}(v)$ and $region^{else}(v)$ with the same depth satisfies the nemesis-sensitive property if and only if 
\begin{equation} \label{eq:nemesisPropertyNode}
    \begin{split}
    \forall n^i \in region^{then}(v) : \forall n^j \in region^{else}(v) \text{ \textit{such that} } i=j :  \\ 
    latencies(n^i) = latencies(n^j)
    \end{split}
\end{equation}
where $latencies(n)$ is a function mapping a node $n$ to its latency sequence. This property states that the latency sequence of any two nodes that are the same distance away 
from some secret-dependent node need to have identical latency sequences. If this property holds then the critical sections of latency traces will be identical and cannot be used to 
infer information about the secret-dependent branch. 

Figure \ref{fig:regionExamples} illustrates how the borders of each region are defined. The secret-dependent node is marked in green, while the two branches are marked in red and blue. In the second example, the node marked in purple belongs to both regions. In example \ref{fig:regionExampleA} there is node node such that all paths from the secret-dependent node to a leaf go through it, so the regions extend all the way to the leaves. In example \ref{fig:regionExampleB} all paths that start in the secret-dependent node go through the node 6. Any differences in nodes 7 and 8 can only be used to infer information about the branch in node 6. These nodes therefore do not have to be considered.  


\begin{figure}
 \centering
 \subfloat[]{\includegraphics[height = 6cm]{images/nemesis-property-example-1.png}\label{fig:regionExampleA}}
 \subfloat[]{\includegraphics[height = 6cm]{images/nemesis-property-example-2.png}\label{fig:regionExampleB}} 

 \captionof{figure}{then-else regions for secret-dependent nodes}
 \label{fig:regionExamples}
\end{figure}

\section{Equalising}\label{seq:equalising}
There are 2 structures found in a program's control flow graph that make it impossible to enforce the nemesis-sensitive property for a node as defined in the previous section. 
These structures are shown in figure \ref{fig:problemStructures}.  
The first stage of the algorithm consists of inserting nodes such that these structures no longer occur. 

The first such structure occurs when the program contains some sequence of instructions that is only executed if some condition is true and is illustrated in fig \label{fig:optional}.
In such a CFG there will be some node that has two paths to it from the root where the paths have different lengths. 
One path will contain the node that corresponds to the conditional instructions, while the other path will not.

In such cases it is impossible to equalize the latency traces of the two paths. Because the paths have different lengths one of the latency traces will always be 
longer than the other one. Additionally, because all nodes in the shorter path are also nodes in the longer path it is impossible to modify the shorter path without also
modifying the longer path. Any attempts to lengthen the shorter path therefore also lengthen the longer path. If these paths start at a secret-dependent node it is 
impossible to ensure that the nemesis-sensitive property holds. 

The second problematic structure occurs when one of the branches is shorter than the other one, as shown in figure \label{fig:unequal}. In such cases there will be some nodes in 
one branch that have no corresponding nodes in the other branch, making it impossible to align them. 

The nemesis-sensitive property as defined in section \ref{eq:nemesisPropertyNode} entails that it is impossible for a node to satisfy the property if one of these 
structures occurs in its branches, since in both cases the regions have different depths. 
The first stage of the algorithm therefore consists of first equalizing all path lengths and then 
equalizing branches. 
Algorithms \ref{alg:equalizePaths} and \ref{alg:equalizeBranches} depict pseudo-code for equalizing paths lengths and equalizing branches respectively. 

\subsection{Extract Sub-graph}
The different procedures described in this section only need to take into account the branches of secret dependent nodes. 
These branches correspond to the regions $region_{then}(v)$ and $region_{else}(v)$ as defined in section \ref{sec:cfg}.
The procedure \textit{ExtractSubgraph}, shown in \ref{alg:equalizePaths}}, extracts the subset of the graph that contains only the nodes that belong to either one of these regions for a given secret-dependent node. 
The edges of this new CFG are all the edges of the original CFG whose head and tail are a part of this subset. 

To determine which nodes are a part of this subgraph all immediate dominators are determined starting from node $n$. 
A node $u$ is said to dominate another node $w$ with respect to $n$ if every path from $n$ to $w$ passes through 
$u$. 
Node $v$ is the immediate dominator of $w$ if $v$ dominates $w$ and every other dominator of $w$ dominates $v$ \cite{dominator}.
The immediate dominator is determined for each node reachable from $n$. If all leaves reachable from $n$ have the same immediate dominator $d$ then all paths from $n$ to some leaf go through $d$. 
In this case any descendants of $d$ are not part of $region_{then}(v)$ or $region_{else}(v)$ and do not have to be included in the sub-graph. 

If such a node $d$ exists then the nodes that are a part of the sub-graph are all nodes that are on a path from $n$ to $d$. If $d$ does not exists 
the sub-graph nodes are all nodes that are on a path from $n$ to some leaf. This definition is analogous to the definition for $region_{else}(v)$ and $region_{then}(v)$ as defined in section \ref{sec:cfg}.

\subsection{Equalize paths}

To equalize all path lengths starting from some secret-dependent node $v$, first a subset of the graph's nodes are extracted such that 
only the regions $region^{then}(v)$ and $region^{else}(v)$ are considered.  
Next the length of the longest path is computed from $v$ to all nodes in the sub-graph. 

Let $(u, v)$ be an edge in the sub-graph. Let $d(u)$ and $d(v)$ be the length of the longest path to $u$ and $v$. If the difference between $d(u)$ and $d(v)$ is more than 
one then there exists at least two paths to $v$. The first path goes through $u$ and has length $d(u)+1$. The second path goes through a different predecessors of $d(v)$ and has 
length $d(v)$. 

The procedure for equalizing the path lengths iterates over all edges of the sub-graph. If the distances to $u$ and $v$ differ by more than one then nodes are inserted 
into the edge between $u$ and $v$ such that the path that goes to $v$ through $u$ is of the same length as the longest path to $v$. 

\subsection{Equalize branches}
The branches of the CFG can be equalized in a similar way. Given some secret-dependent node $v$ a subset of the graph's nodes are extracted. 
The lengths of the longest paths are computed for all nodes in the sub-graph. 
The maximum path length is then determined as being the longest path length to some node that is also leaf. 
The procedure then iterates over all leaves in the sub-graph and determines the difference between the distance to the leaf and the maximum path length. 
If this difference is larger than zero then additional nodes are inserted as the predecessor to the leaf until the distance to the leaf is equal to the maximum 
path length. Because the final instruction in a leaf is a return statement any new nodes have to be added as predecessors. 

\begin{figure}
 \centering
 \subfloat[optional node]{\includegraphics[height = 6cm]{images/optional.png}\label{fig:optional}}
 \subfloat[unequal branches]{\includegraphics[height = 6cm]{images/unequal.png}\label{fig:unequal}} 

 \captionof{figure}{problematic structures in CFG}
 \label{fig:problemStructures}
\end{figure}

\section{Alignment} \label{seq:alignment}

During the alignment stage the nodes of the CFG are aligned in a level-wise manner. 
The alignment of a set of nodes consists of inserting instructions such that all instructions at a given position across all nodes in the set have the same latency. 
The level of a node is defined as being the distance between the root of the graph and the node. The first stage of the algorithm ensures that all paths to a given nodes have the same length making the level of a node a well 
defined value. The alignment stage iterates over all the levels of the sub-graph and aligns the set of nodes found at that level. Algorithm \ref{alg:align} depicts pseudocode for this stage of the algorithm.

\subsection{Basic Operation}
The core of the alignment operation consists of repeatedly selecting a reference node and inserting instructions into the other nodes to match the latencies of the reference node. 
Each iteration a set of candidate nodes is determined, from which the reference node is then selected. 

An index variable $i_{ref}$ is used to keep track of the position of the first instruction that has not yet been aligned. This variable is initially equal to zero and is incremented every iteration. 
The instruction at position $i_{ref}$ in the reference node is called the reference instruction.

The algorithm iterates over all nodes that are not the reference node and verifies if the instruction at position $i_{ref}$ has the same latency. 
If the two latencies are not equal or if the node is shorter than the reference node a new instruction is inserted at position$i_{ref}$. 
The latency of this new instruction is equal to the latency of the reference instruction. 
Once this has been repeated for all nodes in the set then all instruction with at position $i_{ref}$ have the same latency and the variable can be incremented. 

\subsection{Selecting the Reference Node}
Because an instruction is potentially added to each node that is not the reference node the reference node needs to have at least as many instructions as the node with the largest number of instructions. 
This ensure that at some point all nodes have the same number of instructions. 
The set of candidate nodes therefore consists of all nodes that have $n_{max}$ instructions, where $n_{max}$ is the number of instructions in the longest node. 

The selection of the reference node also determines the reference instruction. 
If there are any instructions at position $i_{ref}$ that are not a branching or return instruction then the reference instruction cannot be a branching or return instruction. 
Branching instructions and return instructions are special cases that will result in the insertion of a branching instruction. 
If there is a regular instruction in some node at position $i_{ref}$ then inserting a branching instruction can lead to errors in the control flow of the program. 

The reference node has to be selected such this situation cannot occur. From the set of candidates only those nodes are considered that do not have a branching instruction at position $i_{ref}$. 
From this subset a reference node can be selected arbitrarily. If among the candidates all nodes have a branching instruction at $i_{ref}$ then it is safe to insert a branching instruction 
and a reference node can also be selected arbitrarily. 
 
\subsection{Constructing NOP instruction}
For each latency class a template NOP instruction has been determined. 
The instruction can be inserted into the program as-is if it has no effect on the program state, i.e. it does not modify any register values. 
If the instruction does modify some register the algorithm selects a registers that can safely be used. 
This needs to be a register that is not in use at the time of execution of the instruction. 

There are two types of free registers. 
A register can be free because its current value is no longer used. This occurs when the register is overwritten at some later point without being read first. 
Alternatively a register can be free because it isn't used anywhere in the current function. 
In the latter case, however, it is possible that the register is in use by the caller, since there is no guarantee that the caller stored all the registers it uses. 

The function is statically analyzed to determine which registers are free to use for this purpose. 
If a register of the first type exists then it can be used as the operand of the NOP instruction and the resulting instruction 
can be inserted as-is into the node. If no such registers exists, a free register of the second type is selected. 
In this case additional instructions are inserted into the program to ensure that the original value of the register is not lost. 
In the root of the CFG additional instructions are inserted to push the register value onto the stack, while in every leaf instructions are inserted 
that pop the value from the stack. 

If there are no free registers available, any register is arbitrarily selected. Additional instructions are inserted before and after the NOP instruction to push and pop the register value. To ensure the nodes are 
still balanced these push and pop instructions are inserted across all nodes of the current level. 

If the reference instruction is a branching instruction the the NOP instruction will also be a branching instruction. The target of the branching instruction is then the address of the first instruction of the node's successors. 

\begin{algorithm*}
  \SetAlgoLined
  \DontPrintSemicolon
  
  \SetKwFunction{equalizePathsFnName}{EqualizePathLengths}
  \SetKwFunction{extractSubgraphFNName}{ExtractSubGraph}
  \SetKwFunction{computeLongestPathFNName}{ComputeLongestPathLengths}
  \SetKwFunction{CreateNodeFNName}{CreateNode}
  \SetKwFunction{InsertNodeFNName}{InsertNodeBetween}
  \SetKwFunction{edges}{Edges}
  \SetKwFunction{nodes}{Nodes}
  \SetKwFunction{leaves}{Leaves}
  \SetKwFunction{topologicalorder}{TopologicalOrder}
  \SetKwFunction{successors}{Successors}
  \SetKwFunction{predecessors}{Predecessors}
  \SetKwFunction{addNode}{AddNode}
  \SetKwFunction{addEdge}{AddEdge}
  \SetKwFunction{removeEdge}{RemoveEdge}
  \SetKwFunction{max}{Max}
  \SetKwProg{equalizePaths}{Procedure}{}{}
  
   \equalizePaths{\equalizePathsFnName{g: CFG, v: Node}}{
   \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
   \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
   \ForAll{(u, v) $\in$ \edges{subgraph}}{
   diff $\leftarrow$  \textit{longestPathLengths}[u] - longestPathLengths[v] \\
   \uIf{diff $>$ 1}{
        \textit{head} $\leftarrow$ v \\ 
        \For{$i \in$ 1, 2, ..., diff-1}{
%            \FSetLatencies(node, target\_latencies)
            \textit{newNode} $\leftarrow$ \CreateNodeFNName{} \\
            \InsertNodeFNName{newNode, u, head} \\
            \textit{head} $\leftarrow$ newNode \\
        }
   }
   }
   }{}
   
     \SetKwProg{ComputeLongestPathLengths}{Function}{}{}
  \ComputeLongestPathLengths{\computeLongestPathFNName{g: CFG, s: Node}}{
  dist = \{n : -1 $\vert$  n $\in$ \nodes{g} \} \\
  dist[s] $\leftarrow$  0 \\
  \ForAll{n $\in$ \topologicalorder{g}}{
    
    \ForAll{succ $\in$ \successors{n}}{
        dist[succ] $\leftarrow$ \max{dist[succ], dist[n] + 1} \\
    }
    
  }
  \KwRet dist \\
  }
  
   \SetKwFunction{computeImmediateDominators}{computeImmediateDominators}
   \SetKwFunction{computeAllPaths}{computeAllPaths}
  \SetKwProg{ExtractSubGraph}{Function}{}{}
  \ExtractSubGraph{\extractSubgraphFNName{g: CFG, n: Node}}{
  \textit{immedidateDominators} $\leftarrow$  \computeImmediateDominators{g, n} \\
  \textit{leafDominators} $\leftarrow$  \{ $u$ $\in$ \nodes{g} $\vert(u, v) \in$ \textit{leafDominators} $ \land v \in$ \leaves{g} \} \\
  
  \uIf{$\vert$ leafDominators $\vert$ = 1}{
    dominator $\leftarrow$  leafDominators[0] \\
  } \uElse{
    dominator $\leftarrow$  $\varnothing$ \\
  }
  
  \textit{subgraphNodes} $\leftarrow$  \{ \} \\
  \uIf{domintor $\neq \varnothing$}{
  	\ForAll{$path \in$ \computeAllPaths{g, n, dominator}}{
  		$subgraphNodes \leftarrow subgraphNodes \cup (\{ p \vert p \in path \} \setminus subraphNodes)$
  	}
  } \uElse{
    \ForAll{l $\in$ \leaves{g}}{
        \ForAll{$path \in$ \computeAllPaths{g, l, dominator}}{
  		$subgraphNodes \leftarrow subgraphNodes \cup (\{ p \vert p \in path \} \setminus subraphNodes)$
  	}
    }
  }
  
  $subgraphEdges \leftarrow \{ (u, v) \vert u \in subgraphNodes \land v \in subgraphNodes \land (u, v) \in $ \edges{g} $\}$

	\KwRet $(subgraphNodes, subgraphEdges)$
  }
  
  \caption{Equalize Path Lengths}
  \label{alg:equalizePaths}
\end{algorithm*}

\begin{algorithm*}
    \SetAlgoLined
    \DontPrintSemicolon
    \SetKwProg{equalizeBranches}{Procedure}{}{}
    \SetKwFunction{equalizeBranchesFNName}{EqualizeBranches}

    \equalizeBranches{\equalizeBranchesFNName{g: CFG, n: Node}}{
    \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
    \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
    \textit{maxPathLength} $\leftarrow$ \max{$\{ longestPathLengths[v] \, \vert \,  v \in  \leaves{subgraph}\}$} \\
    \ForAll{leaf $\in$ \leaves{subgraph}}{
        diff $\leftarrow$ \textit{longestPathLengths[leaf]} - maxPathLength \\
        
        \uIf{diff $>$ 0}{
                $v$ $\leftarrow$ leaf \\
                \For{i $\in$ 1, 2, ..., diff}{
                    newNode $\leftarrow$ \CreateNodeFNName{} \\
                    \addNode{g, newNode} \\
                    \ForAll{$p \in$ \predecessors{v}}{
                        \addEdge{g, (p, newNode)} \\
                        \removeEdge{g, (p, v)} \\
                    }
                    \addEdge{g, (newNode, v)} \\
                }
        }
    }
    }
    \caption{Equalize Branches}
    \label{alg:equalizeBranches}
\end{algorithm*}

\begin{algorithm*}      
    \SetAlgoLined
    \DontPrintSemicolon
    
    \SetKwProg{alignCFG}{Procedure}{}{}
    \SetKwProg{alignNodes}{Procedure}{}{}
    
    \SetKwFunction{alignCFGFNName}{AlignCFG}
    \SetKwFunction{alignNodesFNName}{AlignNodes}
    \SetKwFunction{computeDistanceFromNode}{ComputeDistanceFromNode}
    
    \alignCFG{\alignCFGFNName{g: CFG, n: Node}}{
    subgraph $\leftarrow$ \extractSubgraphFNName{g, v} \\
    pathLengths $\leftarrow$ \computeDistanceFromNode{subgraph, v} \\
    levels $\leftarrow$ \{ l $\; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
    \ForAll{l $\in$ levels}{
        levelNodes $\leftarrow$ \{ $u \; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
        \alignNodesFNName{subraph, levelNodes} \\
    }
    }
    
    \SetKwFunction{countInstruction}{CountInstructions}
    \SetKwFunction{selectReferenceNode}{SelectReferenceNode}
    \SetKwFunction{getNodeInstruction}{GetNodeInstruction}
    \SetKwFunction{latency}{Latency}
    \SetKwFunction{isBranch}{IsBranch}
    \SetKwFunction{isReturn}{IsReturn}
    
    \SetKwFunction{selectRegister}{SelectRegister}
    \SetKwFunction{getNOPInstruction}{GetNOPInstruction}
    \SetKwFunction{getBranchInstruction}{GetBranchInstruction}
    \SetKwFunction{insertInstruction}{insertInstruction}
    
    \alignNodes{\alignNodesFNName{g: CFG, ns : NodeSet}}{
    index $\leftarrow$ 0 \\ 
    \While{True}{
        nodeLengths $\leftarrow$ \{ node: \countInstruction{node} $\; \vert \;$ node $\in$ \nodes{g} \} \\
        candidates $\leftarrow$ \{n $\; \vert \;  n \in$ \nodes{g} $\land$  nodeLengths[n] = \max{nodeLengths} \} \\
        referenceNode $\leftarrow$ \selectReferenceNode{candidates} \\
        referenceInstruction $\leftarrow$ \getNodeInstruction{referenceNode, index} \\
        
        \ForAll{node $\in$ \{n $\vert$ n $\in$ \nodes{g} $\land$ n $\neq$ referenceNode \}}{
            \uIf{index $<$ nodeLength[node] $\; \land \;$  \latency{\getNodeInstruction{node, index}} = \latency{referenceInstruction}}{
                continue
            }
            \uIf{\isBranch{referenceInstruction}}{
                newInstruction $\leftarrow$ \getBranchInstruction{}\\ 
                \insertInstruction{node, newInstruction} \\
            } \uElse{
                reg $\leftarrow$ \selectRegister{} \\ 
                newInstruction $\leftarrow$ \getNOPInstruction{\latency{referenceInstruction}, reg} \\ 
                \insertInstruction{node, newInstruction} \\
            }
        }    
    }
    }
    
    \SetKwProg{selectReferenceNode}{Function}{}{}
    \SetKwFunction{selectReferenceNodeFNName}{SelectReferenceNode}

    \selectReferenceNode{\selectReferenceNodeFNName{candidates: NodeSet, index: Integer}}{
        \For{n $\in$ candidates}{
            candidateInstruction $\leftarrow$ \getNodeInstruction{n, index} \\
            \uIf{$\lnot$ (\isBranch{candidateInstruction} $\lor$ \isReturn{candidateInstruction}) }{
                \KwRet n \\
            }
        }
        \KwRet candidates[0] \\
    }
    
    

    
    \caption{Align CFG}
    \label{alg:align}
\end{algorithm*}