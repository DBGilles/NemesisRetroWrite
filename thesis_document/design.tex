\chapter{Design}
\label{cha:design}

This chapter details the design of the proposed algorithm. Section ... \textbf{TODO}

\section{Algorithm Goals}
\label{seq:goals}
The root cause of the vulnerability exposed by Nemesis is a difference in the latencies of two corresponding instructions in different branches of a 
conditional jump. 
In this context two instructions correspond if they are the same distance away from the conditional jump. 
Van Bulck et. al \cite{Nemesis} convincingly demonstrated that is is possible to exploit this vulnerability by inspecting latency traces of the program.
To create a latency trace the attacker configures a timer such that each instruction of the program is interrupted, effectively single-stepping through the program. 
The attacker then implements the Interrupt Service Routine (ISR) such that it logs the latency of the interrupted instruction \cite{nemesisrepo, sancussupport}.
By varying the input he creates a set of latency traces that will reflect any differences in latencies of corresponding instructions.
Through careful inspection the attacker is able to infer information about which path the control flow of the program followed for a given input. 
If the corresponding instructions are part of a secret-dependent branch then the attacker is then able to infer some information about the value of the secret. 

If the architecture has completely deterministic instruction latencies then a single latency trace per input value is sufficient for an attacker to leak information.
In the presence of advanced architectural features, such as paging, caching, and out-of-order execution, instruction latencies are not deterministic. 
Van Bulck et. al \cite{Nemesis} show that in these cases is still possible to leak information from the program by correlating latency traces from repeated executions over the same input. 
The authors demonstrate that the latency measurements follow a normal distribution across all executions and are able to use basic statistical measures to create an overall latency trace 
of the program. 
	
In their paper Pouyanrad et. al have formally defined the Nemesis-Sensitive property.
Let $region^{then}(ep)$ and $region^{else}(ep)$ capture the set of execution points belonging to the branch target and the other region of some branching instruction $ep$.
Let $ep^i$ be the i'th instruction in a region. A program P with a secret-dependent branch in $ep$ and $region^{then}(ep)$ 
and region $region^{else}(ep)$ with the same number of execution points, satisfies the nemesis-sensitive property if and only if:  

\begin{equation} \label{eq:nemesisProperty}
    \begin{split}
    \forall ep^i \in region^{then}(ep) : \forall ep^j \in region^{else}(ep) \text{ \textit{such that} } i=j :  \\ 
    (s_{ep^i} \xrightarrow[]{t} s_{ep^i_{next}}) \land (s_{ep^j} \xrightarrow[]{t'} s_{ep^j_{next}}) \iff t = t' \\ 
    \end{split}
\end{equation}
\cite{MSP430Detection}

The relation $s \xrightarrow[]{t} s'$ models the transition between program states $s$ and $s'$, declaring that the transition between $s$ and $s'$ takes a time $t$. 
For a given instruction this time $t$ is equal the instruction's latency. This property states that for any two corresponding instructions their latencies should be the same.

If a program satisfies the nemesis-sensitive property then an attacker will not be able to leak information from the program based on its latency traces.
For simple architectures with deterministic instruction latencies the resulting latency traces will be indistinguishable. 
Architectures with more complex features will still have minor differences in the resulting traces due to the random nature of the instruction latencies. 
However these differences will not be large enough to be statistically significant.
As a result the attacker will not be able to infer any information about the control flow of the program. 

The goal of the proposed algorithm is to ensure that latency traces cannot leak information by enforcing the nemesis-sensitive property.
The algorithm inserts additional instructions into secret-dependent branches such that corresponding instruction always have the same latency. 
These instruction are carefully constructed such that they have no effect on the program output. 

%\section{Introduction}	
%
%The root cause of the vulnerability exposed by Nemesis-style attacks are differences in the latencies of two instruction that occur at the same 
%position in two branches of a secret-dependent branching instruction. 
%In practice an attacker can exploit this vulnerability by generating latency traces along different paths of the program's control flow. 
%Any differences in instruction latencies will be reflected as differences in these latency traces. 
%By carefully inspecting the relevant sections of the latency traces the attacker can infer which paths were taken for a given input. 
%In cases where the path depends on some secret data the attacker is then able to infer information about this data, successfully leaking information from the program \cite{Nemesis}.
%
%The goal of the algorithm outlined in this section is to ensure that latency traces cannot be used to leak information in this way.
%It does this by inserting additional instructions into branches of a secret-dependent branching instruction. These instructions 
%are carefully selected such that they have the same latency as their corresponding instruction in the other branch. This ensures that
%any instructions that occur at the same position in two different branches have the same latency. As a result the sections of latency traces
%that correspond to these branches will be identical, making it impossible for an attacker to infer information. 
%
%
%The proposed algorithm inserts additional instructions into the functions of a program through manipulation of the function's control flow graph (CFG). 
%This graph consists of nodes and vertices, where each node contains a sequence of instructions. 
%One of the main operations performed on the graph is the alignment of a set of nodes. 
%This operation consists of inserts additional instructions into nodes such that all instructions at a given position in any of the nodes have the same latency. 
%
%Not all structures found in a control flow graph are suitable for alignment. The aforementioned alignment operation therefore has some conditions on the structure of the control flow graph that need to be met. 
%The other main operation of the algorithm consists of inserting additional nodes into the graph such that these conditions are met. 
%
%Section \ref{sec:property} will formally define the property that needs to hold for a program in order for Nemesis-style attacks to be mitigated. Section \ref{sec:cfg} 
%introduces the CFG data structure and translates the aforementioned property to such structures. Finally, sections \ref{seq:equalising} and \ref{seq:alignment} describe the insertion and alignment of nodes, respectively. 
%
%\section{Nemesis-sensitive property}\label{sec:property}
%In their paper Pouyanrad et. al have formally defined the Nemesis-Sensitive property.  Let $region^{then}(ep)$ and $region^{else}(ep)$ capture the set of execution points belonging to the branch target and the other region of some branching instruction $ep$. Let $ep^i$ be the i'th instruction in a region. A program P with a secret-dependence branch in $ep$ and $region^{then}(ep)$ 
%and region $region^{else}(ep)$ with the same number of execution points, satisfies the nemesis-sensitive property if and only if:  
%
%\begin{equation} \label{eq:nemesisProperty}
%    \begin{split}
%    \forall ep^i \in region^{then}(ep) : \forall ep^j \in region^{else}(ep) \text{ \textit{such that} } i=j :  \\ 
%    (s_{ep^i} \xrightarrow[]{t} s_{ep^i_{next}}) \land (s_{ep^j} \xrightarrow[]{t'} s_{ep^j_{next}}) \iff t = t' \\ 
%    \end{split}
%\end{equation}
%\cite{MSP430Detection}
%
%The relation $s \xrightarrow[]{t} s'$ models the transition between program states $s$ and $s'$, declaring that the transition between $s$ and $s'$ takes a time $t$. 
%For a given instruction this time $t$ is equal the instruction's latency. This property states that for any two corresponding instructions in the branches their latencies should be the same.
%
%If this nemesis-sensitive property holds for a program then an attacker is not able to infer which branch was taken by the program based on latency traces of the program.

\section{CFG}\label{sec:cfg}

The algorithm makes modifications to a program's functions by manipulating the Control Flow Graph (CFG), a data structure that represents the control flow of a function.
If a program has multiple functions then each function is represented by a separate CFG. 
A CFG consists of nodes $V$ and directed edges $E$. Each node $v$ contains a 
contiguous sequence of instructions that is always executed as a whole. This implies that a branching instruction can only be found at the end of a node, 
and an instruction that is the target of a branching instruction can only occur at the start.

An edge is drawn from node $v$ to node $v'$ if and only if the last instruction in $v$ can be followed by the first instruction in $v'$ 
when following program control flow. The algorithm only considers branching instructions that are binary in nature, so a node in the CFG can have at most two successors. 
A node is said to be secret-dependent if its last instructions is a 
secret-dependent branching instruction. 

Each node has a latency sequence associated with it. This latency sequence is equal to the latencies of the node's instructions.  
A latency trace along a path of the CFG is then equal to the concatenation of the latency sequences of each node along the path.
Figure \ref{fig:exampleCFG} shows an example of a such a CFG, along with the original program it is created from. The CFG also contains the latency for each instruction. Note that by convention the only node with no incoming edges is considered the starting node of the CFG. 

\begin{figure}
\centering
\begin{subfigure}{.4\textwidth}
  \centering
  
    \begin{lstlisting}[language=C]
int main(){
        int a = 10; 
        int b = 20; 
        if (a < b){
            int temp = b; 
            b = a; 
            a = temp; 
        } 
        return a;  
}\end{lstlisting}
  \caption{C program}
  \label{fig:c_program}
\end{subfigure}%
\begin{subfigure}{.7\textwidth}
  \centering
  \includegraphics[width=.7\textwidth]{images/sample_program_graph.png}
  \caption{Corresponding CFG}
  \label{fig:c_program_cfg}
\end{subfigure}
\caption{Example program with corresponding CFG}
\label{fig:exampleCFG}
\end{figure}

Following the property described in property \ref{eq:nemesisProperty}, the nemesis-sensitive property can be defined for a node in the CFG. Let $v$ be a secret-dependent node. 
Let $v_f$ be a node such that all paths from $v$ to some leaf go through $v_f$. Then $region^{then}(v)$ can be defined as the set of nodes reachable following the 
first of $v$'s outgoing edges up to and including $v_f$ and $region^{else}(v)$ as the set of nodes reachable following the other outgoing edge up to and including $v_f$.

Any differences in the latency sequences of two nodes can only be used to infer which branch was taken at the nearest branching point that is an ancestor of both nodes. 
Any differences in latencies between two nodes that are descendants of $v_f$ can therefore only be used to infer information about which branch was taken at $v_f$. 
This means that all nodes below $v_f$ do not have to be considered. If no such node $v_f$ exists then the regions simply consist of all nodes reachable from $v$ through one of its outgoing edges. 

The depth of $region(v)$ is defined as being the length of the longest path from $v$ to some node $v' \in region(v)$ that does not contain a cycle.
Let $n^i \in region(v)$ be a node such that there is a path going to it from node $v$ of length $i$. 
A secret-dependent node $v$ and $region^{then}(v)$ and $region^{else}(v)$ with the same depth satisfies the nemesis-sensitive property if and only if 
\begin{equation} \label{eq:nemesisPropertyNode}
    \begin{split}
    \forall n^i \in region^{then}(v) : \forall n^j \in region^{else}(v) \text{ \textit{such that} } i=j :  \\ 
    latencies(n^i) = latencies(n^j)
    \end{split}
\end{equation}
where $latencies(n)$ is a function mapping a node $n$ to its latency sequence. This property states that the latency sequence of any two nodes that are the same distance away 
from some secret-dependent node must have identical latency sequences. If this property holds then the critical sections of latency traces will be identical and cannot be used to 
infer information about the secret-dependent branch. 

Figure \ref{fig:regionExamples} illustrates how the borders of each region are defined. The secret-dependent node is marked in green, while the two branches are marked in red and blue. In the second example, the node marked in purple belongs to both regions. In example \ref{fig:regionExampleA} there is no node such that all paths from the secret-dependent node to a leaf go through it, so the regions extend all the way to the leaves. In example \ref{fig:regionExampleB} all paths that start in the secret-dependent node go through the node 6. Any differences in nodes 7 and 8 can only be used to infer information about the branch in node 6. These nodes therefore do not have to be considered.  

\begin{figure*}[t!]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/nemesis-property-example-1.png}
        \caption{}
        \label{fig:regionExampleA}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/nemesis-property-example-2.png}
        \caption{}
        \label{fig:regionExampleB}
    \end{subfigure}
    \caption{then-else regions for secret-dependent nodes}
    \label{fig:regionExamples}
\end{figure*}

\section{Equalising}
\label{seq:equalising}
There are two structures that can occur in a function's CFG that make it impossible to enforce the nemesis-sensitive property for a node as defined in the previous section. 
These structures are shown in figure \ref{fig:problemstructures}.  
The first stage of the algorithm consists of inserting nodes such that these structures no longer occur. 

The first such structure, illustrated in figure \ref{fig:optional}, occurs when a function contains some sequence of instructions that is only executed if some condition is true.
Analogously the corresponding CFG will contain a node that is only reached if the condition is true.
A consequence of this is that there will be some node in the CFG that has at least two paths to it. 
One path will contain the conditional node while the other will not. 
Additionally, the path with the conditional node will be longer than the other path. 
%In such cases it is impossible to align the latency traces of the two paths since one of the latency traces will always be longer than the other one. 
Because the nodes in the shorter path form a subset of the nodes in the longer path it is impossible to modify the shorter path without also modifying the longer path, making it 
impossible to ever equalize the traces along the two paths.

The second problematic structure occurs when one of the branches is shorter than the other one, as shown in figure \ref	{fig:unequal}. 
If one branch is shorter than the other then there will be some nodes in the longer branch that have no corresponding  nodes in the shorter branch. 
This makes it impossible to align them. 

The nemesis-sensitive property as defined in section \ref{eq:nemesisPropertyNode} entails that it is impossible for a node to satisfy the property if one of these 
structures occurs in its branches, since in both cases the regions have different depths. 
The first stage of the algorithm therefore consists inserting additional nodes into the CFG such that all path lengths to a given node are equal as well as all branch depths. 
Algorithms \ref{alg:equalizePaths} and \ref{alg:equalizeBranches} depict the procedures for equalizing paths lengths and equalizing branches respectively. 

 
\begin{figure*}[t!]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/optional.png}
        \caption{optional node}
        \label{fig:optional}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/unequal.png}
        \caption{unequal branches}
        \label{fig:unequal}
    \end{subfigure}
    \caption{problematic structures in CFG}
    \label{fig:problemstructures}
\end{figure*}

\subsection{Extract Sub-graph}
The different procedures described in this section only need to take into account the branches of secret dependent nodes. 
These branches correspond to the regions $region_{then}(v)$ and $region_{else}(v)$ as defined in section \ref{sec:cfg}.
The procedure \textit{ExtractSubgraph}, shown in algorithm \ref{alg:equalizePaths}}, extracts the subset of the graph that contains only the nodes that belong to 
either one of these regions for a given secret-dependent node. 
The edges of this new CFG are all the edges of the original CFG whose head and tail are a part of this subset. 

To determine which nodes are a part of this subgraph all immediate dominators are determined starting from node $n$. 
A node $u$ is said to dominate another node $w$ with respect to $n$ if every path from $n$ to $w$ passes through 
$u$. 
Node $v$ is the immediate dominator of $w$ if $v$ dominates $w$ and every other dominator of $w$ dominates $v$ \cite{dominator}.
The immediate dominator is determined for each node reachable from $n$. If all leaves reachable from $n$ have the same immediate dominator $d$ then all paths from $n$ to some leaf go through $d$. 
In this case any descendants of $d$ are not part of $region_{then}(v)$ or $region_{else}(v)$ and do not have to be included in the sub-graph. 

If such a node $d$ exists then the nodes that are a part of the sub-graph are all nodes that are on a path from $n$ to $d$. If $d$ does not exists 
the sub-graph nodes are all nodes that are on a path from $n$ to some leaf. This definition is analogous to the definition for $region_{else}(v)$ and $region_{then}(v)$ as defined in section \ref{sec:cfg}.

\subsection{Equalize Path Lengths}

The procedure for equalizing all path lengths is show in algorithm \ref{alg:equalizePaths}.
Let $v$ be the secret-dependent node. 
First the subset of the graph is extracted such that 
only the regions $region^{then}(v)$ and $region^{else}(v)$ are considered.  
Next the length of the longest path is computed from $v$ to all nodes in the sub-graph. 

Let $(u, v)$ be an edge in the sub-graph. Let $d(u)$ and $d(v)$ be the length of the longest path to $u$ and $v$. If the difference between $d(u)$ and $d(v)$ is more than 
one then there exist at least two paths to $v$. The first path goes through $u$ and has length $d(u)+1$. The second path goes through a different predecessor of $v$ and has 
length $d(v)$. 

The solution is based on the observation that the edge $(u, v)$ is a part of the shorter path. 
Additional nodes can be inserted between $u$ and $v$ to increase its length until it is as long as the longest path. 
All other paths to $v$ will be unaffected. 

The procedure  iterates over each edge of the subgraph. If the distances to $u$ and $v$ differ by more than one then nodes are inserted 
into the edge between $u$ and $v$ until the path is sufficiently long. The number of nodes that need to be inserted is equal to $d(v) - d(u) - 1$

Figure \ref{fig:equalize-paths} illustrates this procedure.
Each node in the graph is labeled with the length of the longest path to it. 
Figure \ref{fig:equalize-paths-1} has two edges drawn between nodes where the difference between the path lengths is more than one. These edges are marked in red and blue. 
Additional nodes are inserted to get the graph shown in figure \ref{fig:equalize-paths-2}. 


\begin{figure*}[t!]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/equalize_paths_1.png}
        \caption{original CFG}
        \label{fig:equalize-paths-1}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/equalize_paths_2.png}
        \caption{equalized CFG}
        \label{fig:equalize-paths-2}
    \end{subfigure}
    \caption{Equalizing path lengths}
    \label{fig:equalize-paths}
\end{figure*}

\subsection{Equalize branches}
The branches of the CFG can be equalized in a similar way. 
The procedure for doing so is shown in algorithm \ref{alg:equalizeBranches}.
Given some secret-dependent node $v$ the subset of the CFG is extracted that contains $region_{then}(v)$ and $region_{else}(v)$. 
The lengths of the longest paths are computed for all nodes in the sub-graph. 
The maximum path length is then determined as being the longest path length to one of the leaves of the CFG.
The procedure iterates over all leaves in the sub-graph and determines the difference between the distance to the leaf and the maximum path length. 
If this difference is larger than zero then additional nodes are inserted as the predecessor to the leaf until the distance to the leaf is equal to the maximum 
path length. Any additional nodes have to be inserted as predecessors because the final instruction in a leaf is a return statement. 

Figure \ref{fig:equalize-branches} shows how nodes are inserted in order to equalize branch depths. The CFG in figure \ref{fig:equalize-branches-1} has one branch with depth equal to one. 
Two additional nodes are added as ancestors to the branch's leaf in order to increase the branch depth to three. The result of this process is shown in \ref{fig:equalize-branches-2}.
\begin{figure*}[t!]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/equalize_branches_example-1.png}
        \caption{original CFG}
        \label{fig:equalize-branches-1}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=6cm]{images/equalize_branches_example-2.png}
        \caption{equalized CFG}
        \label{fig:equalize-branches-2}
    \end{subfigure}
    \caption{Equalizing branch depths}
    \label{fig:equalize-branches}
\end{figure*}

\section{Alignment} \label{seq:alignment}
During the second stage of the algorithm the nodes of the CFG are aligned in a level-wise manner. 
The alignment of a set of nodes consists of inserting instructions such that all instructions at a given position across all nodes in the set have the same latency. 
The level of a node is defined as being the distance between the root of the graph and the node. The first stage of the algorithm ensures that all paths to a given nodes have the same length making the level of a node a 
well-defined value. The alignment stage iterates over all the levels of the sub-graph and aligns the set of nodes found at that level. Algorithm \ref{alg:align} depicts pseudocode for this stage of the algorithm.

\subsection{Basic Operation}
The core of the alignment operation consists of repeatedly selecting a reference node and inserting instructions into the other nodes to match the latencies of the reference. 
Each iteration a set of candidate nodes is determined from which the reference node is then selected. 

An index variable $i_{ref}$ is used to keep track of the position of the first instruction that has not yet been aligned. This variable is initially equal to zero and is incremented every iteration. 
The instruction at position $i_{ref}$ in the reference node is called the reference instruction.

The algorithm iterates over all nodes that are not the reference node and verifies if the instruction at position $i_{ref}$ has the same latency. 
If the two latencies are not equal or if the node is shorter than the reference node a dummy instruction is inserted at position$i_{ref}$. 
The latency of this new instruction is equal to the latency of the reference instruction. 
Once this has been repeated for all nodes in the set then all instruction at position $i_{ref}$ have the same latency and the variable can be incremented. 


\subsection{Selecting the Reference Node}
Because an instruction is potentially added to each node that is not the reference node the reference node needs to have at least as many instructions as the node with the largest number of instructions. 
This ensure that at some point all nodes have the same number of instructions. 
The set of candidate nodes therefore consists of all nodes that have $n_{max}$ instructions, where $n_{max}$ is the number of instructions in the longest node. 

A branching instruction is a special case that will result in the insertion of dummy branching instructions into the other nodes. 
Additionally a branching instruction cannot be inserted into he middle of a node since this will change the program's control flow. 
A node can therefore not be selected as the reference node when the instruction at position $i_{ref}$ is a branching instruction, unless during the very last iteration.

If among the set of candidate nodes there is at least one node with a non-branching instruction at position $i_{ref}$ then this node is selected as the reference node. 
If there are multiple such nodes then a candidate node can be selected arbitrarily. 
The case where all candidate nodes have a branching instruction at position $i_{ref}$ can only occur during the very last iteration. 
At this point any of the candidate nodes are suitable and one is selected arbitrarily again. 

\subsection{Constructing NOP instruction}
\label{sec:nop}
Any instructions that is inserted into the program can have no effect on the program outcome. In this regard they are the same as the no-operation instruction and are 
referred to as NOP instructions. For each latency class a template NOP instruction has been determined. 
For some latency classes a NOP instruction exists that has no effect on the program state. These can be inserted into the program as-is. 
For other latency classes the NOP instruction modifies some register value. In these cases the algorithm selects a registers that can safely be used. 
This needs to be a register that is not in use at the time of execution of the instruction in order to guarantee that the program outcome is not changed. 

There are two types of free registers. 
Firstly a register can be free because its current value is no longer used.
This occurs when the register is overwritten at some later point without being read first. 
Alternatively a register can be free because it isn't used anywhere in the current function. 
In the latter case, however, it is possible that the register is in use by the caller, since there is no guarantee that the caller stored all the registers it uses. 

The function is statically analyzed to determine which registers are free to use for this purpose. 
If a register of the first type exists then it can be used as the operand of the NOP instruction and the resulting instruction 
can be inserted as-is into the node. 
If no such registers exists, a free register of the second type is selected. 
In this case additional instructions are inserted into the program to ensure that the original value of the register is not lost. 
In the root of the CFG a push instruction is inserted to store the register value onto the stack. 
A pop instruction is then inserted in every leaf of the CFG to restore the register value. 
Once these instructions have been inserted the register effectively becomes a free register of the first type and can 
later be reused when construction additional NOP instructions.

If there are no free registers available, any register is arbitrarily selected. Additional instructions are inserted before and after the NOP instruction to push and pop the register value. To ensure the nodes are 
still balanced these push and pop instructions are inserted across all nodes of the current level. 

If the reference instruction is a branching instruction the the NOP instruction will also be a branching instruction. 
A dummy label is inserted at the start of the node's successor. This label then becomes the target of the branching instruction. 

If the reference instruction is a call to a function then the NOP instruction will be  a call to the same function. The instruction is simply duplicated into the current node. 
If the function contains no secret dependent node then this ensures that any latency traces cannot leak information from the program. Otherwise the function that is called needs to be aligned as well. 
It is only safe to insert a call to a function this way if the function in question has no effects on the program state. If the function does modify the program state then inserting additional calls can 
result in erroneous program outputs. 



\begin{figure}
    
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[width=4cm]{images/align-example-1.png}
        \caption{$i_{ref}=0$, reference latency = 1}
        \label{fig:align-example-1}
    \end{subfigure}%
    ~
	\begin{subfigure}[t]{0.5\textwidth}
    \centering
    \includegraphics[width=4cm]{images/align-example-2.png}
    \caption{$i_{ref}=1$, reference latency = 2}
    \label{fig:align-example-2}
    \end{subfigure}%    
  	
	\begin{subfigure}[t]{0.5\textwidth}
		\centering
    	\includegraphics[width=4cm]{images/align-example-3.png}
    	\caption{$i_{ref}=2$, reference latency = 4}
    	\label{fig:align-example-3}
    \end{subfigure}%
    ~
    \begin{subfigure}[t]{0.5\textwidth}
    \centering
    \includegraphics[width=4cm]{images/align-example-4.png}
    \caption{$i_{ref}=3$, reference latency = 4}
    \label{fig:align-example-4}
    \end{subfigure}
    
    \begin{subfigure}[t]{0.5\textwidth}
    \centering
    \includegraphics[width=4cm]{images/align-example-5.png}
    \caption{$i_{ref}=4$, nodes aligned}
    \label{fig:align-example-5}
    \end{subfigure}

    \caption{Example of alignment of a set of three nodes}
    \label{fig:align-example}
\end{figure}

\subsection{Example}
Figure \ref{fig:align-example} illustrates the different iterations of the alignment of a set of three nodes. 
Each node is labeled with its latency sequence. The set of instructions that have been aligned are underlined. Each iteration the variable $i_{ref}$ is incremented by one. 
The set of candidate nodes is marked in each iteration by a red rectangle. 
If there are multiple candidate nodes with non-branching instructions at position $i_{ref}$ then the first node is arbitrarily selected as the reference node.  

\section{The algorithm}


\subsection{Cycles}
The operations described in section \ref{seq:equalising} require the CFG to be acyclic.
To account for this all cycles are removed from the CFG beforehand and later restored. 
The edge that needs to be removed is determined based on the depths of the nodes in the cycle. 
The depth of a node is defined as being the length of the longest path to the node from the root. 
Removing the cycle is done by removing the edge from that graph that connects the deepest node to the most shallow node. 
The tail and head are stored for all edges that are removed so that they can later be restored. 

The removal of these edges has no effect on the operations of the algorithm if the cycle is not nested inside the branch of a secret dependent node.  
Cycles within a branch of a secret dependent node are not supported by the proposed algorithm.
In this case the algorithm correctly aligns the nodes of the branches but the latency traces will still not be identical.
The branch that contains the cycle will be executed a higher number of times, resulting in a longer latency trace. 



\subsection{Secret-dependent branches}
The detection of secret dependent branches is not part of the algorithm or the implementation. The user has to provide the algorithm with the address of the target instruction. 
At the time of writing secret dependent branching instructions need to be identified through manual inspection. However, research has shown that static detection of these side channels is possible, though 
this is currently limited to the MSP430 architecture \cite{MSP430Detection}.

\subsection{Closing timing leaks}
Algorithm \ref{alg:closeleaks} illustrates the top-level operation of the algorithm. 
The secret-dependent branching instructions are passed to the algorithm as arguments. 
Based on the given instructions the secret-dependent nodes of the CFG are determined. 
These are all nodes that contain a secret-dependent instruction. 
First the equalizing operations are applied for each secret-dependent node. 
Only once all necessary nodes have been inserted is the CFG aligned.
This order of operations ensures that the algorithm works correctly even when secret-dependent node is nested inside the branch of another secret-dependent node. 
This can occur when, for example, a program contains a nested if-statement. Cycles are removed from the CFG and restored as described in the previous section.


\begin{algorithm*}
  \SetAlgoLined
  \DontPrintSemicolon
  
  \SetKwFunction{equalizePathsFnName}{EqualizePathLengths}
  \SetKwFunction{extractSubgraphFNName}{ExtractSubGraph}
  \SetKwFunction{computeLongestPathFNName}{ComputeLongestPathLengths}
  \SetKwFunction{CreateNodeFNName}{CreateNode}
  \SetKwFunction{InsertNodeFNName}{InsertNodeBetween}
  \SetKwFunction{edges}{Edges}
  \SetKwFunction{nodes}{Nodes}
  \SetKwFunction{leaves}{Leaves}
  \SetKwFunction{topologicalorder}{TopologicalOrder}
  \SetKwFunction{successors}{Successors}
  \SetKwFunction{predecessors}{Predecessors}
  \SetKwFunction{addNode}{AddNode}
  \SetKwFunction{addEdge}{AddEdge}
  \SetKwFunction{removeEdge}{RemoveEdge}
  \SetKwFunction{max}{Max}
  \SetKwProg{equalizePaths}{Procedure}{}{}
  
   \equalizePaths{\equalizePathsFnName{g: CFG, v: Node}}{
   \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
   \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
   \ForAll{(u, v) $\in$ \edges{subgraph}}{
   diff $\leftarrow$  \textit{longestPathLengths}[u] - longestPathLengths[v] \\
   \uIf{diff $>$ 1}{
        \textit{head} $\leftarrow$ v \\ 
        \For{$i \in$ 1, 2, ..., diff-1}{
%            \FSetLatencies(node, target\_latencies)
            \textit{newNode} $\leftarrow$ \CreateNodeFNName{} \\
            \InsertNodeFNName{newNode, u, head} \\
            \textit{head} $\leftarrow$ newNode \\
        }
   }
   }
   }{}
   
     \SetKwProg{ComputeLongestPathLengths}{Function}{}{}
  \ComputeLongestPathLengths{\computeLongestPathFNName{g: CFG, s: Node}}{
  dist = \{n : -1 $\vert$  n $\in$ \nodes{g} \} \\
  dist[s] $\leftarrow$  0 \\
  \ForAll{n $\in$ \topologicalorder{g}}{
    
    \ForAll{succ $\in$ \successors{n}}{
        dist[succ] $\leftarrow$ \max{dist[succ], dist[n] + 1} \\
    }
    
  }
  \KwRet dist \\
  }
  
   \SetKwFunction{computeImmediateDominators}{computeImmediateDominators}
   \SetKwFunction{computeAllPaths}{computeAllPaths}
  \SetKwProg{ExtractSubGraph}{Function}{}{}
  \ExtractSubGraph{\extractSubgraphFNName{g: CFG, n: Node}}{
  \textit{immedidateDominators} $\leftarrow$  \computeImmediateDominators{g, n} \\
  \textit{leafDominators} $\leftarrow$  \{ $u$ $\in$ \nodes{g} $\vert(u, v) \in$ \textit{leafDominators} $ \land v \in$ \leaves{g} \} \\
  
  \uIf{$\vert$ leafDominators $\vert$ = 1}{
    dominator $\leftarrow$  leafDominators[0] \\
  } \uElse{
    dominator $\leftarrow$  $\varnothing$ \\
  }
  
  \textit{subgraphNodes} $\leftarrow$  \{ \} \\
  \uIf{domintor $\neq \varnothing$}{
  	\ForAll{$path \in$ \computeAllPaths{g, n, dominator}}{
  		$subgraphNodes \leftarrow subgraphNodes \cup (\{ p \vert p \in path \} \setminus subraphNodes)$
  	}
  } \uElse{
    \ForAll{l $\in$ \leaves{g}}{
        \ForAll{$path \in$ \computeAllPaths{g, l, dominator}}{
  		$subgraphNodes \leftarrow subgraphNodes \cup (\{ p \vert p \in path \} \setminus subraphNodes)$
  	}
    }
  }
  
  $subgraphEdges \leftarrow \{ (u, v) \vert u \in subgraphNodes \land v \in subgraphNodes \land (u, v) \in $ \edges{g} $\}$

	\KwRet $(subgraphNodes, subgraphEdges)$
  }
  
  \caption{Equalize Path Lengths}
  \label{alg:equalizePaths}
\end{algorithm*}

\begin{algorithm*}
    \SetAlgoLined
    \DontPrintSemicolon
    \SetKwProg{equalizeBranches}{Procedure}{}{}
    \SetKwFunction{equalizeBranchesFNName}{EqualizeBranches}

    \equalizeBranches{\equalizeBranchesFNName{g: CFG, n: Node}}{
    \textit{subgraph} $\leftarrow$ \extractSubgraphFNName(g, v) \\  
    \textit{longestPathLengths} $\leftarrow$ \computeLongestPathFNName{subgraph, v} \\
    \textit{maxPathLength} $\leftarrow$ \max{$\{ longestPathLengths[v] \, \vert \,  v \in  \leaves{subgraph}\}$} \\
    \ForAll{leaf $\in$ \leaves{subgraph}}{
        diff $\leftarrow$ \textit{longestPathLengths[leaf]} - maxPathLength \\
        
        \uIf{diff $>$ 0}{
                $v$ $\leftarrow$ leaf \\
                \For{i $\in$ 1, 2, ..., diff}{
                    newNode $\leftarrow$ \CreateNodeFNName{} \\
                    \addNode{g, newNode} \\
                    \ForAll{$p \in$ \predecessors{v}}{
                        \addEdge{g, (p, newNode)} \\
                        \removeEdge{g, (p, v)} \\
                    }
                    \addEdge{g, (newNode, v)} \\
                }
        }
    }
    }
    \caption{Equalize Branches}
    \label{alg:equalizeBranches}
\end{algorithm*}

\begin{algorithm*}      
    \SetAlgoLined
    \DontPrintSemicolon
    
    \SetKwProg{alignCFG}{Procedure}{}{}
    \SetKwProg{alignNodes}{Procedure}{}{}
    
    \SetKwFunction{alignCFGFNName}{AlignCFG}
    \SetKwFunction{alignNodesFNName}{AlignNodes}
    \SetKwFunction{computeDistanceFromNode}{ComputeDistanceFromNode}
    
    \alignCFG{\alignCFGFNName{g: CFG, v: Node}}{
    subgraph $\leftarrow$ \extractSubgraphFNName{g, v} \\
    \tcp{Compute distances from $v$ to all nodes in $subgraph$}
    pathLengths $\leftarrow$ \computeDistanceFromNode{subgraph, v} \\
    levels $\leftarrow$ \{ l $\; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
    \ForAll{l $\in$ levels}{
        levelNodes $\leftarrow$ \{ $u \; \vert \; u \in$ \nodes{subgraph} $\land$ pathLengths[u] = l \} \\
        \alignNodesFNName{subraph, levelNodes} \\
    }
    }
    
    \SetKwFunction{countInstruction}{CountInstructions}
    \SetKwFunction{selectReferenceNode}{SelectReferenceNode}
    \SetKwFunction{getNodeInstruction}{GetNodeInstruction}	
    \SetKwFunction{latency}{Latency}
    \SetKwFunction{isBranch}{IsBranch}
    \SetKwFunction{isReturn}{IsReturn}
    
    \SetKwFunction{selectRegister}{SelectRegister}
    \SetKwFunction{getNOPInstruction}{GetNOPInstruction}
    \SetKwFunction{getBranchInstruction}{GetBranchInstruction}
    \SetKwFunction{insertInstruction}{insertInstruction}
    
    \alignNodes{\alignNodesFNName{g: CFG, ns : NodeSet}}{
    index $\leftarrow$ 0 \\ 
    \While{True}{
        nodeLengths $\leftarrow$ \{ node: \countInstruction{node} $\; \vert \;$ node $\in$ \nodes{g} \} \\
        candidates $\leftarrow$ \{n $\; \vert \;  n \in$ \nodes{g} $\land$  nodeLengths[n] = \max{nodeLengths} \} \\
        referenceNode $\leftarrow$ \selectReferenceNode{candidates} \\
        referenceInstruction $\leftarrow$ \getNodeInstruction{referenceNode, index} \\
        
        \ForAll{node $\in$ \{n $\vert$ n $\in$ \nodes{g} $\land$ n $\neq$ referenceNode \}}{
            \uIf{index $<$ nodeLength[node] $\; \land \;$  \latency{\getNodeInstruction{node, index}} = \latency{referenceInstruction}}{
                continue
            }
            \uIf{\isBranch{referenceInstruction}}{
                newInstruction $\leftarrow$ \getBranchInstruction{}\\ 
                \insertInstruction{node, newInstruction} \\
            } \uElse{
                reg $\leftarrow$ \selectRegister{} \\ 
                newInstruction $\leftarrow$ \getNOPInstruction{\latency{referenceInstruction}, reg} \\ 
                \insertInstruction{node, newInstruction} \\
            }
        }    
    }
    }
    
    \SetKwProg{selectReferenceNode}{Function}{}{}
    \SetKwFunction{selectReferenceNodeFNName}{SelectReferenceNode}

    \selectReferenceNode{\selectReferenceNodeFNName{candidates: NodeSet, index: Integer}}{
        \For{n $\in$ candidates}{
            candidateInstruction $\leftarrow$ \getNodeInstruction{n, index} \\
            \uIf{$\lnot$ (\isBranch{candidateInstruction} $\lor$ \isReturn{candidateInstruction}) }{
                \KwRet n \\
            }
        }
        \KwRet candidates[0] \\
    }
    
       
    \caption{Align CFG}
    \label{alg:align}
\end{algorithm*}

\begin{algorithm*}
    \SetAlgoLined
    \DontPrintSemicolon
    
    
    \SetKwProg{closeTimingLeaks}{Procedure}{}{}
    \SetKwProg{alignNodes}{Procedure}{}{}
    
    \SetKwFunction{closeTimingLeaksName}{CloseTimingLeaks}
    \SetKwFunction{alignNodesFNName}{AlignNodes}
    \SetKwFunction{computeDistanceFromNode}{ComputeDistanceFromNode}
	\SetKwFunction{removeCycles}{RemoveCycles}    
    \SetKwFunction{restoreCycles}{RestoreCycles}    
    
    \closeTimingLeaks{\closeTimingLeaksName{g: CFG, instrs: [Instruction]}}{	
     	targetNodes $\leftarrow$ $\{ n \vert n \in $\nodes{g}$ \land  \exists instr \in instrs : instr \in n \}$ \\
     	removedEdges $\leftarrow$ \removeCycles{g} \\
     	\ForAll{node $\in$ targetNodes}{
     		\equalizePathsFnName{g, node} \\
     		\equalizeBranchesFNName{g, node} \\
     	}

     	\ForAll{node $\in$ targetNodes}{
     		\alignCFGFNName{g, node} \\	
     	}
		
		\restoreCycles{g, removedEdges} \\
     	
    }
    \caption{Close timing leaks}
    \label{alg:closeleaks}
\end{algorithm*}