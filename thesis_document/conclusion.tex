
\chapter{Conclusion}

\section{Discussion}
One limitation of the proposed algorithm is the lack of support for cycles within secret-dependent branches.
However, the evaluation shows that the algorithm is effective in closing timing leaks in programs where this does not occur. 
This indicates that it is possible modify the algorithm such that it is able to close these leaks even in the presence of cycles. 

The root cause of the issue is the fact that a section of the first branch will be executed a higher number of times than the corresponding section in the second branch. 
As a result one of the latency traces will be longer, even when the relevant nodes are aligned.
A solution that addresses this would have to make more extensive changes to the program. 
Before aligning the nodes, the structure of the cycle would have to be duplicated into the second branch such that the corresponding section is is executed the same number of times. 
This requires additional analysis to determine which register contains the loop counter and how many time it is incremented. 
The duplication of the cycle also requires more significant changes than those implemented by the current algorithm. % hier nog aangeven waarom / welke aanpassingen? 
Due to the added complexity such a solution is not included in the proposed algorithm and is left to future research. 

A second limitation is the incomplete coverage of the latency data. There are certain instructions for which there is no available data. 
If these instructions are encountered in branches of  a secret-dependent branching instruction then the algorithm is not able to close the timing leaks. 
However this issue was not encountered during evaluation of the algorithm. 
This indicates that the most commonly used instructions are present in the data and that the coverage of the data is sufficient to close timing leaks in most programs. 

The evaluation of the effectiveness of the algorithm is based on a statistical analysis of the program before and after alignment. 
If the instruction latencies are fully deterministic then the static analysis tool can correctly predict the actual run-time instruction latencies. The resulting analysis 
is then sufficient for demonstrating that the algorithm correctly closes all timing leaks. 
In the presence of advanced micro-architectural features the instruction latencies are to some extend random, however. 
As a result the run-time latencies diverge from the predicted latencies. 
Although the results indicate that all timing leaks are closed it is possible that some differences still exist between branches because of these random variations. 
Because of this additional experiments are needed to fully verify if the algorithm is effective for complex architectures with non-deterministic latencies.
Empirical measurements in the form of latency traces are needed to determine if an attacker can still distinguish between branches of a secret-dependent conditional node. 



\subsection{Secret-dependent branches}
The detection of secret dependent branches is not part of the algorithm or the implementation. The user has to provide the algorithm with the address of the target instruction. 
At the time of writing secret dependent branching instructions need to be identified through manual inspection. However, research has shown that static detection of these side channels is possible, though 
this is currently limited to the MSP430 architecture \cite{MSP430Detection}.

\section{Future work}
