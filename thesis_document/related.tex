
\chapter{Related Work}
\label{cha:related}
This chapter discusses a number of countermeasures that have been proposed for closing timing side-channels. 
These can broadly be categorized as being either software-based or hardware-based. 
Hardware-based solution are based on modification to the architecture and are discussed in section \ref{sec:hardware}, whereas the software-based solutions discussed in section \ref{sec:software} are implemented at the language level \cite{Barthe}.  
\section{Software-based approaches}
\label{sec:software}

Popular software-based approaches to closing timing-leaks include constant-time policies and the program counter model \cite{Barthe}. 
Constant time policies require that memory access and control-flow should not depend on secret data. 
Unfortunately writing code that adheres to these policies can be difficult, since it requires knowledge of the compiler, and requires developers to deviate from 
conventional programming practices.
A number of solutions have been proposed to verify if a program adheres to constant-time policies \cite{verify-constant-time, Barthe}.

Molnar et al. \cite{programcounter} first introduced the program counter model in their work, proposing methods for the detection and mitigation of control-flow side channel attacks. 
The authors consider the case where an adversary is able to make an observation of a side channel at each step of the computation. 
The result is a sequence of observations $T= (T_1, T_2, ... T_n)$ called a \textit{transcript}.
The \textit{program counter model} or \textit{PC model} is then the model where each value of the transcript is the processor's program counter during the computation. 
A program is then said to be  PC-secure if this transcript is secure. 
The authors state that \textit{any program that is PC-secure will also be secure against timing attacks}.
Based on this definition of PC-security the authors introduce a code transformation for creating PC-secure C code.
The authors note that they made a number of assumptions in their work. 
Although these assumptions do not hold for a number of architectures the authors are confident 
that they are reasonable for some embedded devices. 	

Winderix et al. \cite{WinderixHans} recently proposed a new algorithm that aligns instructions in corresponding branches in a way similar to the algorithm outlined in this text, 
by first equalizing path lengths and then aligning nodes. 
They have implemented their algorithm for the Sancus architecture, in the form of a compiler pass in the LLVM structure. Their solution supports loops nested within secret-dependent branches 
and as a result covers a larger set of programs. Unlike the solution proposed in this work, however, their solution cannot be applied to off-the-shelf binaries, as it requires access to the source code and recompilation.  
 
\section{Hardware-based approaches}
\label{sec:hardware}

An orthogonal approach is to close timing leaks using hardware-based solutions. 
Recently Busi et al. \cite{busi} proposed an approach to extend architectures with non-interruptible enclaved execution such that they can also support interruptions without breaking 
the existing isolation properties. Based on this approach, they proposed  a design for interruptible enclaves that are resistent against interrupt attacks. 
This design is based on an earlier version of Sancus with non-interruptible enclaves. They modify the architecture to add padding cycles whenever the enclave is interrupted, effectively closing timing leaks. 

A limitation of their approach is that their design is based on the assumption that the timing of instruction is predictable. This is generally not the case for more complex architectures such as Intel's x86\_64.
Additionally their approach requires hardware modifications, which means it cannot be applied to off-the-shelf and existing devices. 

